<!-- casino/templates/casino/slot_game.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>拉霸機 Demo (改良版)</title>
    <!-- 引入 Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  </head>
  <body style="background: #222; color: #fff; margin:0;">
    <div id="game-container"></div>

    <!-- Django 模板變數：user_id, points -->
    <script>
      let userId = {{ user_id|default:0 }};
      let currentPoints = {{ points|default:0 }};
    </script>

    <script>
      // Phaser 設定
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'game-container',
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };
      const game = new Phaser.Game(config);

      // 全域變數
      let reelContainers = [];  // 3 個捲軸的容器
      let spinning = false;

      function preload() {
        // 載入外框圖
        this.load.image("machineFrame", "/static/casino/slot_frame.png"); 
        // 載入符號
        this.load.image("symbol1", "/static/casino/symbol1.png");
        this.load.image("symbol2", "/static/casino/symbol2.png");
        this.load.image("symbol3", "/static/casino/symbol3.png");
        this.load.image("symbol4", "/static/casino/symbol4.png");
        this.load.image("wild",    "/static/casino/wild.png");
      }

      function create() {
        const scene = this;

        // 1) 加入拉霸機外框 (中心放在 400,300；可微調)
        const frame = scene.add.image(400, 300, "machineFrame");
        frame.setDepth(0); // 在最底層

        // 2) 建立三個捲軸容器 (示範 x=260, 400, 540; y=180)
        //   每個容器裡放 4 張符號 sprite，垂直分佈
        const startX = [260, 400, 540];
        for(let i=0; i<3; i++){
          let reelContainer = scene.add.container(startX[i], 180);
          // 塞 4 張預設符號
          for(let j=0; j<4; j++){
            let randKey = Phaser.Utils.Array.GetRandom(["symbol1","symbol2","symbol3","symbol4","wild"]);
            let spr = scene.add.sprite(0, j*100, randKey);
            reelContainer.add(spr);
          }
          reelContainer.setDepth(1); 
          reelContainers.push(reelContainer);
        }

        // 3) 顯示當前積分
        scene.pointText = scene.add.text(10, 10, `Points: ${currentPoints}`, {
          fontSize: '24px',
          color: '#FFD700'
        });

        // 4) Spin 按鈕
        const spinButton = scene.add.text(350, 500, "SPIN", {
          fontSize: '32px',
          backgroundColor: '#cc0000',
          color: '#fff',
          padding: { x: 20, y: 10 }
        }).setInteractive();

        spinButton.on('pointerdown', () => {
          console.log("Spin button clicked!");
          if(!spinning) {
            startSpinAPI(scene, userId, 10);
          }
        });
      }

      function update() {
        // 不需要做什麼
      }

      // ================
      // 呼叫後端 API
      // ================
      function startSpinAPI(scene, userId, bet){
        spinning = true;
        if(userId === 0){
          alert("尚未登入或 userId 無效！");
          spinning = false;
          return;
        }

        fetch("/casino/slot/spin/", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            user_id: userId,
            bet: bet
          })
        })
        .then(res => res.json())
        .then(data => {
          if(data.error){
            alert(data.error);
            spinning = false;
            return;
          }
          // data: { reels: [...], win_amount, current_points }
          // reels 例如 ["symbol2","wild","symbol1"]

          // 5) 執行更逼真的轉動
          spinAllReels(scene, data.reels, data.win_amount, data.current_points);
        })
        .catch(err => {
          console.error("API Error:", err);
          spinning = false;
        });
      }

      // ================
      // 真實轉動
      // ================
      /**
       * 依序轉動三個捲軸，最後停在後端指定的 reels 結果
       */
      function spinAllReels(scene, reelResult, win, newPoints){
        // 設定每個捲軸轉動時間 & 延遲
        // 例如：第一個 2 秒 -> 第二個 2.5 秒 -> 第三個 3 秒
        let durations = [2000, 2500, 3000];
        reelContainers.forEach((reelC, index) => {
          spinReel(scene, reelC, durations[index], reelResult[index], () => {
            // 當最後一個捲軸也停下來
            if(index === reelContainers.length - 1){
              spinning = false;
              currentPoints = newPoints;
              scene.pointText.setText(`Points: ${currentPoints}`);
              if(win > 0){
                alert(`恭喜贏了 ${win} 點!`);
              }
            }
          });
        });
      }

      /**
       * 轉動單一捲軸 (reelContainer)，於 duration 毫秒後停止，
       * 最後一格對準 finalSymbol。
       */
      function spinReel(scene, reelContainer, duration, finalSymbol, onStop){
        // 每 80 ms 移動一次
        let speed = 30; // 每次移動多少像素
        let event = scene.time.addEvent({
          delay: 80,
          loop: true,
          callback: () => {
            reelContainer.y += speed;
            // 若任何 sprite 超過某閾值，就移回上方
            reelContainer.list.forEach(spr => {
              let globalY = reelContainer.y + spr.y;
              if(globalY > 600){ // 600=遊戲高度
                spr.y -= 400; // 4張*100=400
                // 隨機換符號 => 模擬持續滾動
                let possible = ["symbol1","symbol2","symbol3","symbol4","wild"];
                spr.setTexture(Phaser.Utils.Array.GetRandom(possible));
              }
            });
          }
        });

        // duration 毫秒後停止轉動
        scene.time.delayedCall(duration, () => {
          event.remove(); // 停止上述 callback
          // 校正捲軸位置 => reelContainer.y % 100
          let offset = reelContainer.y % 100;
          reelContainer.y -= offset; // 對齊

          // 把「容器中最上方(或中間)的 sprite」換成 finalSymbol
          // 這裡視你的顯示範圍而定：如果畫面中顯示第 1 格，就把它改 finalSymbol
          let topSprite = reelContainer.list[0];
          // 由於可能被移動過，你可以找「最接近 180~280」的 sprite 來換
          // 這裡簡化直接改 [0]
          topSprite.setTexture(finalSymbol);

          // 可視需求再微調 spr.y, reelContainer.y 使 finalSymbol 保持在可見範圍
          // ...

          // 呼叫完成後的回調
          if(typeof onStop === 'function'){
            onStop();
          }
        });
      }
    </script>
  </body>
</html>
