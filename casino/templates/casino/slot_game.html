<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>拉霸機 Demo (改良版)</title>
    <!-- 引入 Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  </head>
  <body style="background: #222; color: #fff; margin:0;">
    <div id="game-container"></div>

    <!-- Django 模板變數：user_id, points -->
    <script>
      let userId = {{ user_id|default:0 }};
      let currentPoints = {{ points|default:0 }};
    </script>

    <script>
      // Phaser 設定
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'game-container',
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };
      const game = new Phaser.Game(config);

      // 全域變數：每個捲軸都是一個 "container" 中有 3 個 sprite
      let reelContainers = [];
      let spinning = false;

      function preload() {
        // 載入外框圖 (229×102 => 兩倍)
        this.load.image("machineFrame", "/static/casino/slot_frame.png");
        // 載入符號
        this.load.image("symbol1", "/static/casino/symbol1.png");
        this.load.image("symbol2", "/static/casino/symbol2.png");
        this.load.image("symbol3", "/static/casino/symbol3.png");
        this.load.image("symbol4", "/static/casino/symbol4.png");
        this.load.image("wild",    "/static/casino/wild.png");
      }

      function create() {
        const scene = this;

        // 1) 放置外框
        const frame = scene.add.image(400, 300, "machineFrame").setScale(2);

        // ---------------------------------------------------
        // 2) 建立一個矩形當「可視範圍」，然後做 geometryMask
        //    以下數字要依你的機台位置微調
        // ---------------------------------------------------
        const maskRect = scene.add.rectangle(400, 300, 450, 190, 0x00ff00);
        maskRect.setVisible(false);  // 不顯示綠色方塊，只做mask用
        const reelMask = maskRect.createGeometryMask();

        // 3) 建立三個捲軸容器
        //    參考你給的位置： x=400±145, y=300+10
        const reelPositions = [
          { x: 400 - 145, y: 300 + 12 },
          { x: 400,       y: 300 + 12 },
          { x: 400 + 145, y: 300 + 12 }
        ];

        reelPositions.forEach(pos => {
          let reelContainer = scene.add.container(pos.x, pos.y);

          // 建立 3 個 sprite (上、中、下)
          // sprite0: y = -120, sprite1: y=0, sprite2: y=120 (可自行調整)
          let possibleKeys = ["symbol1","symbol2","symbol3","symbol4","wild"];
          for (let i = 0; i < 3; i++) {
            let randKey = Phaser.Utils.Array.GetRandom(possibleKeys);
            let spr = scene.add.sprite(0, (i - 1) * 150, randKey);
            reelContainer.add(spr);
          }

          // ★ 對該捲軸容器套用 mask
          reelContainer.setMask(reelMask);

          reelContainers.push(reelContainer);
        });

        // 4) 顯示當前積分
        scene.pointText = scene.add.text(10, 10, `Points: ${currentPoints}`, {
          fontSize: '24px',
          color: '#FFD700'
        });

        // 5) Spin 按鈕
        const spinButton = scene.add.text(400, 500, "SPIN", {
          fontSize: '32px',
          backgroundColor: '#cc0000',
          color: '#fff',
          padding: { x: 20, y: 10 }
        })
        .setOrigin(0.5)
        .setInteractive();

        spinButton.on('pointerdown', () => {
          if (!spinning) {
            startSpinAPI(scene, userId, 10);
          }
        });
      }

      function update() {
        // 無特別需求
      }

      // =========================================
      // 呼叫後端 API
      // =========================================
      function startSpinAPI(scene, userId, bet) {
        spinning = true;

        fetch("/casino/slot/spin/", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            user_id: userId,
            bet: bet
          })
        })
        .then(res => res.json())
        .then(data => {
          if (data.error) {
            alert(data.error);
            spinning = false;
            return;
          }
          // data: { reels: [...], win_amount, current_points }
          spinAllReels(scene, data.reels, data.win_amount, data.current_points);
        })
        .catch(err => {
          console.error("API Error:", err);
          spinning = false;
        });
      }

      // =========================================
      // 真實轉動: 每個捲軸容器上下移動 2秒, 結束後顯示最終符號
      // =========================================
      function spinAllReels(scene, reelResults, win, newPoints) {
        let completed = 0;
        let duration = 2000; // 2 秒

        reelContainers.forEach((container, i) => {
          spinOneReel(scene, container, reelResults[i], duration, () => {
            completed++;
            if (completed === reelContainers.length) {
              // 全部捲軸都停下
              spinning = false;
              currentPoints = newPoints;
              scene.pointText.setText(`Points: ${currentPoints}`);
              if (win > 0) {
                alert(`恭喜贏了 ${win} 點!`);
              }
            }
          });
        });
      }

      /**
       * 對單一捲軸容器做短暫的「向下滾動」，超出下邊的 sprite 移回上面，循環數秒
       * 結束後在中間 sprite 顯示後端傳回的結果 finalKey
       */
      function spinOneReel(scene, reelContainer, finalKey, duration, onStop) {
        let startTime = scene.time.now;
        let spinEvent = scene.time.addEvent({
          delay: 80,   // 每80 ms 更新一次
          loop: true,
          callback: () => {
            // 向下移動
            reelContainer.list.forEach(spr => {
              spr.y += 1000; // 速度
              if (spr.y > 50) {
                // 超過下邊, 移到最上方 -160 (因為間距是80*2)
                spr.y -= 150; 
                // 換個隨機符號, 模擬不斷滾動
                let possible = ["symbol1","symbol2","symbol3","symbol4","wild"];
                spr.setTexture(Phaser.Utils.Array.GetRandom(possible));
              }
            });

            // 若超過duration => 停止
            if (scene.time.now - startTime >= duration) {
              spinEvent.remove();

              // 校正位置 => 讓中間 sprite 在 y=0
              let middleSpr = findClosestToZero(reelContainer);
              let offset = middleSpr.y;
              reelContainer.list.forEach(spr => {
                spr.y -= offset;
              });

              // 最後把 "中間" 那個 sprite 改成 finalKey
              middleSpr.setTexture(finalKey);

              // 完成後呼叫回調
              if (onStop) onStop();
            }
          }
        });
      }

      // 輔助函式：找出 container 中最接近 y=0 的 sprite (表示中間)
      function findClosestToZero(container) {
        let target = null;
        let minDist = Number.MAX_VALUE;
        container.list.forEach(spr => {
          let dist = Math.abs(spr.y);
          if (dist < minDist) {
            minDist = dist;
            target = spr;
          }
        });
        return target;
      }
    </script>
  </body>
</html>
