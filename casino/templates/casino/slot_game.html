<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>拉霸機 Demo (改良版)</title>
    <!-- 引入 Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  </head>
  <body style="background: #222; color: #fff; margin:0;">
    <div id="game-container"></div>

    <!-- Django 模板變數：user_id, points -->
    <script>
      let userId = {{ user_id|default:0 }};
      let currentPoints = {{ points|default:0 }};
    </script>

    <script>
      // Phaser 設定
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'game-container',
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };
      const game = new Phaser.Game(config);

      // 全域變數：每個捲軸都是一個 "container" 中有 3 個 sprite
      let reelContainers = [];
      let spinning = false;

      function preload() {
        // 載入外框圖 (229×102 => 放大2倍)
        this.load.image("machineFrame", "/static/casino/slot_frame.png");
        // 載入符號
        this.load.image("symbol1", "/static/casino/symbol1.png");
        this.load.image("symbol2", "/static/casino/symbol2.png");
        this.load.image("symbol3", "/static/casino/symbol3.png");
        this.load.image("symbol4", "/static/casino/symbol4.png");
        this.load.image("wild",    "/static/casino/wild.png");
      }

      function create() {
        const scene = this;

        // ---------------------------------------------------
        // 1) 建立一個矩形當「可視範圍」(geometryMask)，只顯示該範圍內的捲軸
        //    可依實際圖的大小和位置做微調
        // ---------------------------------------------------
        const maskRect = scene.add.rectangle(400, 300, 450, 190, 0x00ff00);
        maskRect.setVisible(false); // 不顯示綠色方塊，只用來做 mask
        const reelMask = maskRect.createGeometryMask();

        // ---------------------------------------------------
        // 2) 建立三個捲軸容器 (depth=0) 並套用 mask
        //    例如中心點 y=300 - 10, spacing=80
        // ---------------------------------------------------
        const reelPositions = [
          { x: 400 - 145, y: 300 - 10 },
          { x: 400,       y: 300 - 10 },
          { x: 400 + 145, y: 300 - 10 }
        ];

        reelPositions.forEach(pos => {
          let reelContainer = scene.add.container(pos.x, pos.y).setDepth(0);

          let possibleKeys = ["symbol1","symbol2","symbol3","symbol4","wild"];
          // 建立 3 個 sprite (上、中、下)，上下相隔 80
          for (let i = 0; i < 3; i++) {
            let randKey = Phaser.Utils.Array.GetRandom(possibleKeys);
            let spr = scene.add.sprite(0, (i - 1) * 80, randKey);
            reelContainer.add(spr);
          }

          // ★ 將該捲軸容器套用 geometryMask
          reelContainer.setMask(reelMask);

          reelContainers.push(reelContainer);
        });

        // ---------------------------------------------------
        // 3) 建立外框圖 (depth=10)，蓋在捲軸之上
        // ---------------------------------------------------
        const frame = scene.add
          .image(400, 300, "machineFrame")
          .setScale(2)
          .setDepth(10); // 外框深度高於捲軸容器

        // 4) 顯示當前積分
        scene.pointText = scene.add.text(10, 10, `Points: ${currentPoints}`, {
          fontSize: '24px',
          color: '#FFD700'
        });

        // 5) 建立 Spin 按鈕
        const spinButton = scene.add.text(400, 500, "SPIN", {
          fontSize: '32px',
          backgroundColor: '#cc0000',
          color: '#fff',
          padding: { x: 20, y: 10 }
        })
        .setOrigin(0.5)
        .setInteractive();

        spinButton.on('pointerdown', () => {
          if (!spinning) {
            startSpinAPI(scene, userId, 10);
          }
        });
      }

      function update() {
        // 無特別需求
      }

      // ---------------------------------------
      // 呼叫後端 API
      // ---------------------------------------
      function startSpinAPI(scene, userId, bet) {
        spinning = true;

        fetch("/casino/slot/spin/", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            user_id: userId,
            bet: bet
          })
        })
        .then(res => res.json())
        .then(data => {
          if (data.error) {
            alert(data.error);
            spinning = false;
            return;
          }
          // data: { reels: [...], win_amount, current_points }
          spinAllReels(scene, data.reels, data.win_amount, data.current_points);
        })
        .catch(err => {
          console.error("API Error:", err);
          spinning = false;
        });
      }

      // ---------------------------------------
      // 轉動所有捲軸
      // ---------------------------------------
      function spinAllReels(scene, reelResults, win, newPoints) {
        let completed = 0;
        let duration = 2000; // 2 秒

        reelContainers.forEach((container, i) => {
          spinOneReel(scene, container, reelResults[i], duration, () => {
            completed++;
            if (completed === reelContainers.length) {
              // 全部捲軸都停下
              spinning = false;
              currentPoints = newPoints;
              scene.pointText.setText(`Points: ${currentPoints}`);
              if (win > 0) {
                alert(`恭喜贏了 ${win} 點!`);
              }
            }
          });
        });
      }

      // ---------------------------------------
      // 單一捲軸轉動
      // ---------------------------------------
      function spinOneReel(scene, reelContainer, finalKey, duration, onStop) {
        let startTime = scene.time.now;
        let spinEvent = scene.time.addEvent({
          delay: 80,
          loop: true,
          callback: () => {
            // 捲軸往下移
            reelContainer.list.forEach(spr => {
              spr.y += 10;
              if (spr.y > 48) {
                // 超出下邊 => 移到最上邊
                spr.y -= 144; // 80*3
                let possible = ["symbol1","symbol2","symbol3","symbol4","wild"];
                spr.setTexture(Phaser.Utils.Array.GetRandom(possible));
              }
            });

            // 時間到 => 停止
            if (scene.time.now - startTime >= duration) {
              spinEvent.remove();

              // 校正位置 => 中間 sprite y=0
              let middleSpr = findClosestToZero(reelContainer);
              let offset = middleSpr.y;
              reelContainer.list.forEach(spr => {
                spr.y -= offset;
              });

              // 中間 sprite 改成 finalKey
              middleSpr.setTexture(finalKey);

              if (onStop) onStop();
            }
          }
        });
      }

      // 找出 container 中最接近 y=0 的 sprite
      function findClosestToZero(container) {
        let target = null;
        let minDist = Infinity;
        container.list.forEach(spr => {
          let dist = Math.abs(spr.y);
          if (dist < minDist) {
            minDist = dist;
            target = spr;
          }
        });
        return target;
      }
    </script>
  </body>
</html>
