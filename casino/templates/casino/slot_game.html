<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>拉霸機 Demo：三秒轉動 (1+2), DOM 輸入 BET, 回首頁按鈕</title>
    <!-- 引入 Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
      body {
        background: #222;
        color: #fff;
        margin: 0;
      }
      /* 遊戲畫面容器 */
      #game-container {
        position: relative;
        float: left;
      }
      /* 獎勵紀錄框 */
      #reward-box {
        position: absolute;
        left: 820px;
        top: 10px;
        width: 200px;
        height: 580px;
        border: 1px solid #999;
        background: #222;
        color: #fff;
        overflow-y: auto;
        padding: 10px;
      }
      #reward-box h3 {
        margin: 5px 0;
      }
      /* 其他 DOM 元素 (bet 輸入 / 回首頁按鈕) */
      #bet-container {
        position: absolute;
        top: 620px; /* 遊戲下方 */
        left: 10px;
        color: #fff;
      }
      #betInput {
        width: 80px;
      }
      #homeBtn {
        position: absolute;
        top: 620px;
        left: 200px;
        color: #fff;
        background: #444;
        padding: 6px 12px;
        text-decoration: none;
        border: 1px solid #666;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div id="game-container"></div>

    <!-- 獎勵紀錄框 -->
    <div id="reward-box">
      <h3>獎勵紀錄</h3>
      <div id="reward-logs">尚無紀錄</div>
    </div>

    <!-- BET 輸入框 & 回首頁按鈕 (DOM) -->
    <div id="bet-container">
      <label for="betInput">BET:</label>
      <input type="number" id="betInput" value="10" min="1" max="9999" step="1">
    </div>
    <!-- 回到會員首頁 (自行修改 href 到正確路徑) -->
    <a id="homeBtn" href="/members/home">回會員首頁</a>

    <!-- Django 模板變數：user_id, points -->
    <script>
      let userId = {{ user_id|default:0 }};
      let currentPoints = {{ points|default:0 }};
    </script>

    <script>
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        parent: 'game-container',
        scene: { preload, create, update }
      };
      const game = new Phaser.Game(config);

      let reelContainers = [];
      let spinning = false;
      let autoSpinCount = 0;

      // 總轉動 3秒 => Phase1= 1s, Phase2= 2s
      const PHASE1_DURATION = 500; 
      const PHASE2_DURATION = 2500;

      function preload() {
        // 載入外框
        this.load.image("machineFrame", "/static/casino/slot_frame.png");
        // 載入符號
        this.load.image("symbol1", "/static/casino/symbol1.png");
        this.load.image("symbol2", "/static/casino/symbol2.png");
        this.load.image("symbol3", "/static/casino/symbol3.png");
        this.load.image("symbol4", "/static/casino/symbol4.png");
        this.load.image("wild",    "/static/casino/wild.png");
      }

      function create() {
        const scene = this;

        // 建立 3 個容器(各放 3個 sprite)
        let reelPositions = [
          { x: 400-145, y: 290 },
          { x: 400,     y: 290 },
          { x: 400+145, y: 290 }
        ];
        reelPositions.forEach(pos=>{
          let c = scene.add.container(pos.x, pos.y);
          // 上/中/下
          for(let i=0; i<3; i++){
            let spr = scene.add.sprite(0,(i-1)*80, pickRandomSymbol());
            c.add(spr);
          }
          reelContainers.push(c);
        });

        // 外框
        scene.add.image(400, 300, "machineFrame").setScale(2).setDepth(10);

        // Geometry Mask
        let maskRect = scene.add.rectangle(400,300,440,180,0x00ff00,0).setDepth(15);
        let reelMask = maskRect.createGeometryMask();
        reelContainers.forEach(c => c.setMask(reelMask));

        // Points
        scene.pointText = scene.add.text(10, 10, `Points: ${currentPoints}`, {
          fontSize:'24px', color:'#FFD700'
        });

        // SPIN 按鈕
        let spinBtn = scene.add.text(400,500, "SPIN", {
          fontSize:'32px', backgroundColor:'#cc0000', color:'#fff', padding:{x:20,y:10}
        }).setOrigin(0.5).setInteractive();
        spinBtn.on('pointerdown', () => {
          if(!spinning){
            // 從 DOM 讀取 BET 數字
            let betInput = document.getElementById("betInput");
            let betAmount = parseInt(betInput.value,10) || 10;
            startSpinAPI(scene, userId, betAmount);
          }
        });

        // 自動轉
        scene.add.text(600,480,"自動轉:", {fontSize:'20px',color:'#fff'}).setDepth(20);
        let autoOpts=[30,50,100];
        autoOpts.forEach((opt,i)=>{
          let autoBtn = scene.add.text(600, 500+i*25, `${opt}次`, {
            fontSize:'18px', backgroundColor:'#555', color:'#fff', padding:{x:5,y:2}
          }).setInteractive().setDepth(20);
          autoBtn.on('pointerdown', ()=>{
            if(!spinning && autoSpinCount===0){
              let betInput = document.getElementById("betInput");
              let betAmount = parseInt(betInput.value,10) || 10;
              autoSpinCount=opt;
              startSpinAPI(scene, userId, betAmount);
            }
          });
        });
      }

      function update() {}

      // 呼叫後端
      function startSpinAPI(scene, userId, bet){
        spinning=true;
        fetch("/casino/slot/spin/", {
          method:"POST",
          headers:{"Content-Type":"application/x-www-form-urlencoded"},
          body:new URLSearchParams({
            user_id: userId,
            bet: bet
          })
        })
        .then(r=>r.json())
        .then(data=>{
          if(data.error){
            alert(data.error);
            spinning=false;
            autoSpinCount=0;
            return;
          }
          spinReelsSequentially(scene, data.reels, data.win_amount, data.current_points, bet);
        })
        .catch(err=>{
          console.error("API Error:",err);
          spinning=false; 
          autoSpinCount=0;
        });
      }

      // 依序轉動
      function spinReelsSequentially(scene, reelResults, win, newPoints, usedBet){
        let index=0;
        function spinNext(){
          if(index>=reelContainers.length){
            // 全部完成
            spinning=false;
            currentPoints=newPoints;
            scene.pointText.setText(`Points: ${currentPoints}`);
            if(win>0) addRewardLog(`贏了 ${win} 點 (BET=${usedBet})`);
            // 自動轉
            if(autoSpinCount>0){
              autoSpinCount--;
              if(autoSpinCount>0){
                startSpinAPI(scene, userId, usedBet);
              }
            }
            return;
          }
          // Phase1=1秒 => Phase2=2秒
          doPhase1(scene, reelContainers[index], PHASE1_DURATION, ()=>{
            doPhase2(scene, reelContainers[index], reelResults[index], PHASE2_DURATION, ()=>{
              index++;
              spinNext();
            });
          });
        }
        spinNext();
      }

      // ========== Phase1: 1秒固定速度+隨機換圖 ==========
      function doPhase1(scene, container, duration, onComplete){
        let startTime= scene.time.now;
        let speed=25;

        let phase1Event= scene.time.addEvent({
          delay:40,
          loop:true,
          callback:()=>{
            let elapsed= scene.time.now - startTime;
            if(elapsed>=duration){
              phase1Event.remove();
              if(onComplete) onComplete();
              return;
            }
            // 固定速度
            container.list.forEach(spr=>{
              spr.y += speed;
              if(spr.y>80){
                spr.y-=240;
                spr.setTexture(pickRandomSymbol());
              }
            });
          }
        });
      }

      // ========== Phase2: 2秒漸減速，不換圖 ==========
      function doPhase2(scene, container, finalKey, duration, onComplete){
        let startTime= scene.time.now;
        let baseSpeed=25;

        let phase2Event= scene.time.addEvent({
          delay:40,
          loop:true,
          callback:()=>{
            let elapsed= scene.time.now - startTime;
            let ratio= elapsed/duration;
            let curSpeed= baseSpeed*(1-ratio);
            if(curSpeed<2) curSpeed=2;

            container.list.forEach(spr=>{
              spr.y += curSpeed;
              // 不換圖
              if(spr.y>80){
                spr.y-=240;
              }
            });

            if(elapsed>=duration){
              phase2Event.remove();
              // 校正 => 最接近y=0的 sprite
              let midSpr= findClosestToZero(container);
              let offset= midSpr.y;
              container.list.forEach(s=> s.y-=offset);
              // 最終符號
              midSpr.setTexture(finalKey);
              if(onComplete) onComplete();
            }
          }
        });
      }

      // 輔助函式
      function pickRandomSymbol(){
        let syms=["symbol1","symbol2","symbol3","symbol4","wild"];
        return Phaser.Utils.Array.GetRandom(syms);
      }

      function findClosestToZero(container){
        let minDist=99999, target=null;
        container.list.forEach(s=>{
          let d=Math.abs(s.y);
          if(d<minDist){
            minDist=d; target=s;
          }
        });
        return target;
      }

      function addRewardLog(text){
        let logDiv=document.getElementById("reward-logs");
        if(!logDiv)return;
        if(logDiv.innerHTML==="尚無紀錄") logDiv.innerHTML="";
        let now=new Date();
        let line=`[${now.toLocaleTimeString()}] ${text}`;
        logDiv.innerHTML+= line+"<br/>";
        logDiv.scrollTop= logDiv.scrollHeight;
      }
    </script>
  </body>
</html>
